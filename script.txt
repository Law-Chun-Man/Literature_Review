Today I am going to talk about particle based fluid simulation using smoothed particles hydrodynamics. The literature that I reviewed are these 2, one is about using SPH on water animation, another one is about optimisation.

So, why do we use SPH for simulating water? Well, the goal is to animate water for interactive applications. Being interactive means it has to fast. This SPH method was first introduced in 1977 to test the fission hypothesis. Perhaps you could see some similarities there! They both of them are trying to simulate a lot of particles, so we can easily borrow the idea to animate water.

What SPH does is to smooth out the particles to make it more continuous, rather than individual particles. This can allow us to better simulate reality with just limited number of particles.

Let's take a look at the modeling equations. First we have conservation of mass. So, this term is just rate of change of density, and this is just another way of saying the same thing. So they add up to be 0. Another equation is about conservation of momentum. But be careful there, because this is only applicable when the particles are flowing in the same direction as the fluid, which in this case, it does, so we can use this equation. Otherwise, there would be a v dot gradient of v term here.

To put this into numerical calculations, we could use this interpolating equation. Here, A could be any physical quantities, for example, it could be density, or it could be force. Interestingly, when we put density in A, it would simply be mass times the smoothing kernel. Now, let's take a look at force due to pressure, we could interpolate negative gradient of pressure. However, this is not symmetric. What I meant by this is that if you use this equation to calculate the force acting on i by j and on j by i, they will be different in magnitude, as pressure is generally different at different places. What people do to make this symmetric is to just take the average of pressure at 2 points. For force due to velocity, we interpolate the laplacian of velocity. This is also not symmetric, so people usually take the difference of v at two places.

Now, let's take a look at the smoothing kernel, which is the most important component of the equation. So, a smoothing kernel should really look like this where there is a maximum influence at centre, and it will go down to zero at r equal h which is the smoothing radius, and of course it's zero outside the sphere. 

So the paper suggested a few smoothing kernel, let's take a look at the first one. So this does satisfy the boundary conditions, but the change of slope here is very abrupt. So we can just take the cubic of it, and the slope here will be smoothed out. However, we can see that here, it's very spiky. Then we can just take the square of h and r to make this smoother. This is also the smoothing kernel that the paper used for density.

But, for different quantities, we have to use different smoothing kernel. So let's take a look at pressure. If we use the same smoothing kernel as for the density, we can easily see some problems here. When the 2 particles are too close together, the slope will become flat. This is not physical however, because they should really repel more when they are closer together. Therefore, we might as well just use this function for pressure. Now, let's take a look at viscosity. Remember we took laplacian of the velocity to find the force, and the force should only be resistive. So, the laplacian should always be positive. However, if we continue to use the smoothing kernel same as the pressure one, you can see that the laplacian went to negative side. Therefore, the paper suggested another function for viscosity. You can see that this function can satisfy the boundary condition, and have the positive laplacian at the same time. 

Now that we found all the necessary smoothing kernels, but still, there is a slight catch! If you try to use the smoothing kernel and calculate density with different smoothing radius h, you will get different result! This is because the smoothing kernel is not normalised. So here is the normalisation condition, and after you have done the calculations, you will find these results. 

This wraps up the stuff that I want to talk about for SPH. So now I would like to talk about the method from another paper that can help accelerate the calculation. You might have noticed that if we try to loop over all the particles when we do the calculation, we would include many zeros, because smoothing kernel is zero outside the sphere. So we don't really need to calculate all the particle pairs. What the paper suggested is to divide the space into grid, with side length of smoothing radius. Now, we only need to consider the particles in the neighbouring cells. Let me tell you an example. So, in this example, we will need to make an array to store the index of particles. Then, we will make another array to store which cell that particle is in. Now, we will need to sort the cell_id array, and change the particle index array accordingly. After that, we will create one more array, to store the start position. So, let's say you want to find which particles are in this cell, in this cell start array, you will need to look up the index 5 element, and this says one, so you go to the cell id, and look up the index 1 element. When you loop over all the particles with the same cell id number, you essentially loop over all the particles in this cell.

So this is the end.
